"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const yargs = require("yargs");
const lib_1 = require("../lib");
const config_1 = require("../config");
const { argv } = yargs;
const sleep = (timeout) => {
    return new Promise((resolve) => {
        setTimeout(resolve, timeout);
    });
};
const main = async () => {
    const { uri } = config_1.default.rabbit;
    await lib_1.default.connect(uri);
    await lib_1.default.declareTopology({
        exchanges: [{ name: 'ex1', type: 'fanout' }],
        queues: [{ name: 'q1' }, { name: 'q2' }],
        bindings: [
            { source: 'ex1', destination: 'q1' },
            { source: 'ex1', destination: 'q2' },
        ],
    });
    if (!argv.producer) {
        console.log('[Consumer mode] Waiting for incoming messages...');
        await lib_1.default.queue('q2').activateConsumer((message) => {
            console.log('q2 received message: ', message.getContent());
            message.ack();
        });
    }
    else {
        const messageCount = argv.count || 100;
        const timeout = argv.timeout || 1000;
        console.log(`[Producer mode] Sending ${messageCount} messages with ${timeout} ms timeout`);
        for (let i = 0; i < messageCount; i++) {
            const message = `Test ${i}/${messageCount - 1}, timeout: ${timeout} ms`;
            console.log(`Sending message: ${message}`);
            await lib_1.default.exchange('ex1').send(message);
            await sleep(timeout);
        }
        await lib_1.default.close();
    }
};
main().catch((err) => {
    console.error(`Mail failed with error: `, err);
    process.exit(1);
});
//# sourceMappingURL=index.js.map
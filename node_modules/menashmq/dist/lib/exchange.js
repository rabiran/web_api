"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Exchange = void 0;
const internal_1 = require("./internal");
class Exchange {
    constructor(connection, name, type, options = {}) {
        this.name = name;
        this.type = type;
        this.options = options;
        this.exchangeAsserted = false;
        this.channel = new internal_1.Channel(connection);
    }
    async initialize() {
        if (this.isInitialized()) {
            await this.close();
        }
        await this.channel.initialize();
        try {
            await this.getNativeChannel().assertExchange(this.name, this.type, this.options);
        }
        catch (err) {
            await this.channel.close();
            return;
        }
        this.exchangeAsserted = true;
        internal_1.assert(this.isInitialized());
    }
    async close() {
        if (!this.isInitialized()) {
            return;
        }
        await this.channel.close().catch((err) => console.error(`Channel.close() for ${this.name} failed with error:`, err));
        this.exchangeAsserted = false;
        internal_1.assert(!this.isInitialized());
    }
    getNativeChannel() {
        return this.channel.getNativeChannel();
    }
    isInitialized() {
        return this.channel.isInitialized() && this.exchangeAsserted;
    }
    async send(content, routingKey = '', properties = {}) {
        await internal_1.default.waitForInitialize();
        internal_1.assert(this.isInitialized());
        const message = new internal_1.Message(content, properties);
        await internal_1.tryOnce(() => Exchange.publishHelper(this.getNativeChannel(), this.name, routingKey, message.getRawContent(), message.properties), 'exchange');
    }
    static publishHelper(channel, exchange, routingKey, content, options) {
        return new Promise((resolve, reject) => {
            channel.publish(exchange, routingKey, content, options, (err) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve();
                }
            });
        });
    }
    async delete(ifUnused) {
        await internal_1.default.waitForInitialize();
        if (!this.isInitialized()) {
            throw new Error('Exchange is not initialized');
        }
        await internal_1.default.deleteExchange(this.name, ifUnused);
    }
    async bind(source, pattern = '', args) {
        await internal_1.default.waitForInitialize();
        if (!this.isInitialized()) {
            throw new Error('Exchange is not initialized');
        }
        await internal_1.default.bind(source, this, pattern, args);
    }
    static getTypes() {
        return ['fanout', 'topic', 'direct', 'headers'];
    }
}
exports.Exchange = Exchange;
//# sourceMappingURL=exchange.js.map
/// <reference types="node" />
import { Channel, Message, Connection, amqp, ConsumerMessage, Exchange } from './internal';
export declare class Queue {
    name: string;
    options: QueueOptions;
    channel: Channel;
    consumerOptions?: amqp.Options.Consume;
    consumerTag: string | null;
    consumerOnMessage: ConsumeFunction;
    queueAsserted: boolean;
    constructor(connection: Connection, name: string, options?: QueueOptions);
    getNativeChannel(): amqp.ConfirmChannel;
    initialize(): Promise<void>;
    close(): Promise<void>;
    isInitialized(): boolean;
    prefetch(count: number): Promise<void>;
    delete(options?: amqp.Options.DeleteQueue): Promise<void>;
    bind(source: Exchange | string, pattern?: string, args?: any): Promise<void>;
    send(content: Buffer | String | Object, properties?: QueueSendProperties): Promise<void>;
    sendMessage(message: Message): Promise<void>;
    private static sendHelper;
    activateConsumer(onMessage: ConsumeFunction, options?: amqp.Options.Consume): Promise<void>;
    private activateConsumerHelper;
    stopConsumer(): Promise<void>;
}
export interface QueueSendProperties {
    contentType?: any;
    contentEncoding?: any;
    headers?: amqp.MessagePropertyHeaders;
    deliveryMode?: any;
    priority?: any;
    correlationId?: any;
    replyTo?: any;
    expiration?: any;
    messageId?: any;
    timestamp?: any;
    type?: any;
    userId?: any;
    appId?: any;
    clusterId?: any;
}
export interface QueueOptions extends amqp.Options.AssertQueue {
    prefetch?: number;
}
export declare type ConsumeFunction = (message: ConsumerMessage) => any;
//# sourceMappingURL=queue.d.ts.map
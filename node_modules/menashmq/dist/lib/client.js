"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tryOnce = exports.Client = void 0;
const internal_1 = require("./internal");
const defaultRetryOptions = {
    retries: 5,
};
class Client extends internal_1.EventEmitter {
    constructor() {
        super();
        this.connection = null;
        this.bindings = new internal_1.BindingManager();
        this.isReady = false;
        this.isClosed = true;
        this.exchanges = {};
        this.queues = {};
    }
    async connect(url, retryOptions = defaultRetryOptions, socketOptions) {
        if (this.connection) {
            throw new Error('Connection was already created');
        }
        const connection = new internal_1.Connection(url, socketOptions);
        await Client.initializeConnectionWithRetries(connection, retryOptions);
        this.connection = connection;
        this.retryOptions = retryOptions;
        this.isReady = true;
        this.isClosed = false;
    }
    static initializeConnectionWithRetries(connection, retryOptions) {
        return internal_1.pRetry(() => connection.initialize(), retryOptions);
    }
    async initialize() {
        if (this.isReady) {
            return;
        }
        const { err } = await internal_1.trycatch(() => this.initializeHelper());
        if (err) {
            this.isReady = false;
            this.emit('error', err);
            this.close();
            return;
        }
        console.log(`[RabbitMQ Client] Client is ready`);
        this.isReady = true;
        this.emit('ready');
    }
    async initializeHelper() {
        await this.closeAllExchanges();
        await this.closeAllQueues();
        await Client.initializeConnectionWithRetries(this.connection, this.retryOptions);
        await this.rebuildTopology();
    }
    async close() {
        if (this.isClosed) {
            return;
        }
        this.isClosed = true;
        this.bindings.clearBindings();
        await this.closeAllQueues().catch((err) => console.error('closeAllQueues() failed with error:', err));
        await this.closeAllExchanges().catch((err) => console.error('closeAllExchanges() failed with error:', err));
        await this.connection.close().catch((err) => console.error(`[Client] Connection close() failed with error`, err.toString()));
        this.exchanges = {};
        this.queues = {};
        this.connection = null;
        this.emit('close');
    }
    closeAllQueues() {
        const promises = [];
        for (const queue of Object.values(this.queues)) {
            promises.push(queue.close());
        }
        return Promise.all(promises);
    }
    closeAllExchanges() {
        const promises = [];
        for (const exchange of Object.values(this.exchanges)) {
            promises.push(exchange.close());
        }
        return Promise.all(promises);
    }
    async waitForInitialize() {
        if (this.isClosed) {
            throw new Error(`Client was closed`);
        }
        if (!this.isReady) {
            await internal_1.once(internal_1.default, 'ready');
        }
    }
    reportError(source, err) {
        if (!this.isReady) {
            return;
        }
        console.log(`[RabbitMQ Client] Source '${source}' reported error: `, err.toString());
        console.log(`[RabbitMQ Client] Starting reinitialize...`);
        this.isReady = false;
        this.initialize();
    }
    async declareExchange(name, type, options = {}) {
        if (!name) {
            throw new Error('Exchange name is a required parameter');
        }
        if (!type || !internal_1.Exchange.getTypes().includes(type)) {
            throw new Error(`Exchange type is a required parameter and should be one of the following options: ${internal_1.Exchange.getTypes().toString()}`);
        }
        await this.waitForInitialize();
        if (this.exchanges[name]) {
            throw new Error(`Exchange with name ${name} already declared`);
        }
        const exchange = new internal_1.Exchange(this.connection, name, type, options);
        await exchange.initialize();
        this.exchanges[name] = exchange;
        return exchange;
    }
    async declareQueue(name, options = {}) {
        if (!name) {
            throw new Error('Exchange name is a required parameter');
        }
        await this.waitForInitialize();
        if (this.queues[name]) {
            throw new Error(`Queue with name ${name} already declared`);
        }
        const queue = new internal_1.Queue(this.connection, name, options);
        await queue.initialize();
        this.queues[name] = queue;
        return queue;
    }
    queue(name) {
        if (!name) {
            throw new Error('Parameter name should be provided for a queue');
        }
        const queue = this.queues[name];
        if (!queue) {
            throw new Error(`Queue with name ${name} was not declared or was deleted`);
        }
        return queue;
    }
    exchange(name) {
        if (!name) {
            throw new Error('Parameter name should be provided for an exchange');
        }
        const exchange = this.exchanges[name];
        if (!exchange) {
            throw new Error(`Exchange with name ${name} was not declared or was deleted`);
        }
        return exchange;
    }
    async declareTopology(topology) {
        await this.waitForInitialize();
        if (topology.exchanges) {
            await this.declareExchanges(topology.exchanges);
        }
        if (topology.queues) {
            await this.declareQueues(topology.queues);
        }
        if (topology.bindings) {
            await this.applyBindings(topology.bindings);
        }
        if (topology.consumers) {
            await this.activateConsumers(topology.consumers);
        }
    }
    declareQueues(queues) {
        const promises = queues.map((queue) => {
            const { name, options } = queue;
            return this.declareQueue(name, options);
        });
        return Promise.all(promises);
    }
    declareExchanges(exchanges) {
        const promises = exchanges.map((exchange) => {
            const { name, type, options } = exchange;
            return this.declareExchange(name, type, options);
        });
        return Promise.all(promises);
    }
    applyBindings(bindings) {
        const promises = bindings.map((binding) => {
            const { source, destination, pattern, args } = binding;
            return this.bind(source, destination, pattern, args);
        });
        return Promise.all(promises);
    }
    activateConsumers(consumers) {
        const promises = consumers.map((consumer) => {
            const { queueName, onMessage, options } = consumer;
            return this.queue(queueName).activateConsumer(onMessage, options);
        });
        return Promise.all(promises);
    }
    async rebuildTopology() {
        for (const exchange of Object.values(this.exchanges)) {
            await exchange.initialize();
        }
        for (const queue of Object.values(this.queues)) {
            await queue.initialize();
        }
        await this.bindings.rebindAll();
    }
    async deleteExchange(name, ifUnused = true) {
        await this.waitForInitialize();
        const exchange = this.exchanges[name];
        if (!exchange) {
            throw Error(`Exchange with name ${name} does not exist`);
        }
        if (!exchange.isInitialized()) {
            throw Error(`Exchange with name ${name} was not initialized`);
        }
        await this.bindings.unbindAllBindingsForEntity(exchange);
        await exchange.getNativeChannel().deleteExchange(name, { ifUnused });
        await exchange.close();
        delete this.exchanges[name];
    }
    async deleteQueue(name, options = {}) {
        await this.waitForInitialize();
        const queue = this.queues[name];
        if (!queue) {
            throw Error(`Queue with name ${name} does not exist`);
        }
        if (!queue.isInitialized()) {
            throw Error(`Exchange with name ${name} was not initialized`);
        }
        await this.bindings.unbindAllBindingsForEntity(queue);
        await queue.getNativeChannel().deleteQueue(name, options);
        await queue.close();
        delete this.queues[name];
    }
    getEntityByName(entityName) {
        const exchange = this.exchanges[entityName];
        const queue = this.queues[entityName];
        if (exchange && queue) {
            throw new Error('There are both exchange and queue with the same name');
        }
        if (!exchange && !queue) {
            throw new Error(`There is no entity with name ${entityName}`);
        }
        return exchange || queue;
    }
    async bind(source, destination, pattern = '', args) {
        await this.waitForInitialize();
        const sourceEntity = typeof source === 'string' ? this.exchange(source) : source;
        const destinationEntity = typeof destination === 'string' ? this.getEntityByName(destination) : destination;
        await this.bindings.addBinding(sourceEntity, destinationEntity, pattern, args);
    }
    async send(entityName, content, properties, routingKey) {
        if (this.exchanges[entityName]) {
            return this.exchanges[entityName].send(content, routingKey, properties);
        }
        if (this.queues[entityName]) {
            if (routingKey) {
                throw new Error(`Send to queue should not get routingKey parameter`);
            }
            return this.queues[entityName].send(content, properties);
        }
        throw new Error(`Entity with name ${entityName} was not declared`);
    }
}
exports.Client = Client;
exports.tryOnce = async (func, source) => {
    return internal_1.pRetry(() => func(), {
        retries: 1,
        onFailedAttempt: async (error) => {
            internal_1.default.reportError(source, error);
            await internal_1.default.waitForInitialize();
        },
    });
};
//# sourceMappingURL=client.js.map
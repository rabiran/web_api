"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BindingManager = void 0;
const internal_1 = require("./internal");
class BindingManager {
    constructor() {
        this.bindings = [];
    }
    rebindAll() {
        const promises = this.bindings.map((binding) => {
            const { source, destination, pattern, args } = binding;
            return BindingManager.bind(source, destination, pattern, args);
        });
        return Promise.all(promises);
    }
    unbindAll() {
        const promises = this.bindings.map((binding) => {
            const { source, destination, pattern, args } = binding;
            return this.removeBinding(source, destination, pattern, args);
        });
        return Promise.all(promises);
    }
    async addBinding(source, destination, pattern, args) {
        const binding = this.findBinding(source, destination, pattern, args);
        if (binding) {
            throw new Error(`Binding of source ${source.name} and destination ${destination.name}`);
        }
        await BindingManager.bind(source, destination, pattern, args);
        const newBinding = { source, destination, pattern, args };
        this.bindings.push(newBinding);
    }
    static async bind(source, destination, pattern, args) {
        if (!source.isInitialized()) {
            throw new Error(`Source ${source.name} is not initialized`);
        }
        if (!destination.isInitialized()) {
            throw new Error(`Destination ${source.name} is not initialized`);
        }
        if (destination instanceof internal_1.Queue) {
            await source.getNativeChannel().bindQueue(destination.name, source.name, pattern, args);
        }
        else {
            await source.getNativeChannel().bindExchange(destination.name, source.name, pattern, args);
        }
    }
    static async unbind(source, destination, pattern, args) {
        if (!source.isInitialized()) {
            throw new Error(`Source ${source.name} is not initialized`);
        }
        if (!destination.isInitialized()) {
            throw new Error(`Destination ${source.name} is not initialized`);
        }
        if (destination instanceof internal_1.Queue) {
            await source.getNativeChannel().unbindQueue(destination.name, source.name, pattern, args);
        }
        else {
            await source.getNativeChannel().unbindExchange(destination.name, source.name, pattern, args);
        }
    }
    async removeBinding(source, destination, pattern, args) {
        if (!source.isInitialized()) {
            throw new Error(`Source ${source.name} is not initialized`);
        }
        if (!destination.isInitialized()) {
            throw new Error(`Destination ${source.name} is not initialized`);
        }
        const binding = this.findBinding(source, destination, pattern, args);
        if (!binding) {
            throw new Error(`Binding of source ${source.name} and destination ${destination.name} does not exist`);
        }
        await BindingManager.unbind(source, destination, pattern, args);
        this.removeBindingFromArray(binding);
    }
    removeBindingFromArray(binding) {
        this.bindings = this.bindings.filter((arrayBinding) => binding !== arrayBinding);
    }
    async unbindAllBindingsForEntity(entity) {
        if (!entity.isInitialized()) {
            throw new Error(`Entity ${entity.name} is not initialized`);
        }
        const bindings = this.bindings.filter(BindingManager.byEntity(entity));
        const promises = bindings.map((binding) => {
            const { source, destination, pattern, args } = binding;
            return this.removeBinding(source, destination, pattern, args);
        });
        return Promise.all(promises);
    }
    clearBindings() {
        this.bindings = [];
    }
    findBinding(source, destination, pattern, args) {
        let predicate;
        if (!pattern) {
            predicate = BindingManager.bySourceAndDestinationPredicate(source, destination);
        }
        else {
            predicate = BindingManager.byExactMatch(source, destination, pattern, args);
        }
        return this.bindings.find(predicate);
    }
    static isSameEntity(first, second) {
        if (typeof first !== typeof second) {
            return false;
        }
        return first.name === second.name;
    }
    static byEntity(entity) {
        return (binding) => {
            return BindingManager.isSameEntity(binding.source, entity) || BindingManager.isSameEntity(binding.destination, entity);
        };
    }
    static bySourcePredicate(source) {
        return (binding) => {
            return BindingManager.isSameEntity(binding.source, source);
        };
    }
    static byDestinationPredicate(destination) {
        return (binding) => {
            return BindingManager.isSameEntity(binding.destination, destination);
        };
    }
    static bySourceAndDestinationPredicate(source, destination) {
        return (binding) => {
            return BindingManager.bySourcePredicate(source)(binding) && BindingManager.byDestinationPredicate(destination)(binding);
        };
    }
    static byExactMatch(source, destination, pattern, args) {
        return (binding) => {
            return (BindingManager.bySourceAndDestinationPredicate(source, destination)(binding) &&
                binding.pattern === pattern &&
                internal_1.isDeepStrictEqual(binding.args, args));
        };
    }
}
exports.BindingManager = BindingManager;
//# sourceMappingURL=binding.js.map
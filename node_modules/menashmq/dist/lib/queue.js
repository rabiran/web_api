"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Queue = void 0;
const internal_1 = require("./internal");
class Queue {
    constructor(connection, name, options = {}) {
        this.name = name;
        this.options = options;
        this.consumerTag = null;
        this.queueAsserted = false;
        this.channel = new internal_1.Channel(connection);
    }
    getNativeChannel() {
        return this.channel.getNativeChannel();
    }
    async initialize() {
        if (this.isInitialized()) {
            await this.close();
        }
        await this.channel.initialize();
        try {
            await this.getNativeChannel().assertQueue(this.name, this.options);
            if (this.options.prefetch) {
                await this.channel.prefetch(this.options.prefetch);
            }
            if (this.consumerTag) {
                await this.activateConsumerHelper(this.consumerOnMessage, this.consumerOptions);
            }
        }
        catch (err) {
            await this.channel.close();
            throw err;
        }
        this.queueAsserted = true;
    }
    async close() {
        if (!this.isInitialized()) {
            return;
        }
        await this.channel.close();
    }
    isInitialized() {
        return this.channel.isInitialized() && this.queueAsserted;
    }
    async prefetch(count) {
        await internal_1.default.waitForInitialize();
        if (!this.isInitialized()) {
            throw new Error(`Queue is not initialized`);
        }
        await internal_1.tryOnce(() => this.channel.prefetch(count), 'queue');
        this.options.prefetch = count;
    }
    delete(options = {}) {
        return internal_1.default.deleteQueue(this.name, options);
    }
    async bind(source, pattern = '', args) {
        await internal_1.default.waitForInitialize();
        if (!this.isInitialized()) {
            throw new Error('Queue is not initialized');
        }
        await internal_1.default.bind(source, this, pattern, args);
    }
    send(content, properties = {}) {
        const message = new internal_1.Message(content, properties);
        return this.sendMessage(message);
    }
    async sendMessage(message) {
        await internal_1.default.waitForInitialize();
        internal_1.assert(this.channel);
        await internal_1.tryOnce(() => Queue.sendHelper(this.getNativeChannel(), this.name, message.getRawContent(), message.properties), 'queue');
    }
    static sendHelper(channel, queue, content, properties) {
        return new Promise((resolve, reject) => {
            channel.sendToQueue(queue, content, properties, (err) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve();
                }
            });
        });
    }
    async activateConsumer(onMessage, options) {
        await internal_1.default.waitForInitialize();
        if (!this.isInitialized()) {
            throw new Error(`Queue is not initialized`);
        }
        if (this.consumerTag !== null) {
            throw new Error(`Only one consumer could be activated for queue ${this.name}`);
        }
        await this.activateConsumerHelper(onMessage, options);
    }
    async activateConsumerHelper(onMessage, options = { noAck: false }) {
        const consume = async (msg) => {
            if (!msg) {
                return;
            }
            await internal_1.default.waitForInitialize();
            internal_1.assert(this.consumerOptions, '[BUG] Consumer options were not defined');
            const message = internal_1.ConsumerMessage.from(msg, this);
            const { err } = await internal_1.trycatch(() => onMessage(message));
            if (err) {
                internal_1.default.reportError('consumer', new Error(`[BUG] Consumer function of queue ${this.name} throws exception. Message will be rejected. Error: ${internal_1.stringify(err)}`));
                if (this.consumerOptions.noAck === false && !message.isProcessed()) {
                    message.nack(false);
                }
                return;
            }
            if (this.consumerOptions.noAck === false && !message.isProcessed()) {
                internal_1.default.reportError('consumer', new Error(`[BUG] Consumer function of queue ${this.name} should ack, nack or reject message.`));
                message.nack(false);
            }
        };
        const { consumerTag } = await this.getNativeChannel().consume(this.name, consume, options);
        this.consumerTag = consumerTag;
        this.consumerOptions = options;
        this.consumerOnMessage = onMessage;
    }
    async stopConsumer() {
        await internal_1.default.waitForInitialize();
        if (this.consumerTag === null) {
            throw new Error(`Consumer was not activated for queue ${this.name}`);
        }
        await this.getNativeChannel().cancel(this.consumerTag);
        this.consumerTag = null;
    }
}
exports.Queue = Queue;
//# sourceMappingURL=queue.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConsumerMessage = exports.Message = void 0;
const internal_1 = require("./internal");
class Message {
    constructor(content, properties = {}) {
        this.properties = properties;
        this.setContent(content);
    }
    setContent(content) {
        if (typeof content === 'string') {
            this.content = Buffer.from(content);
        }
        else if (Buffer.isBuffer(content)) {
            this.content = content;
        }
        else {
            this.content = Buffer.from(JSON.stringify(content));
            this.properties.contentType = 'application/json';
        }
    }
    getContent() {
        let content = this.content.toString();
        if (this.properties.contentType === 'application/json') {
            content = JSON.parse(content);
        }
        return content;
    }
    getRawContent() {
        return this.content;
    }
}
exports.Message = Message;
class ConsumerMessage extends Message {
    constructor(message, queue) {
        super(message.content, message.properties);
        this.message = message;
        this.queue = queue;
        this.acked = false;
        this.nacked = false;
        this.fields = message.fields;
    }
    ack() {
        if (this.isProcessed()) {
            throw new Error(`[BUG] message already processed ack: ${this.acked} nack: ${this.nacked}`);
        }
        internal_1.assert(this.queue.channel);
        this.queue.getNativeChannel().ack(this.message);
        this.acked = true;
    }
    nack(requeue = true, allUpTo = false) {
        if (this.isProcessed()) {
            throw new Error(`[BUG] message already processed ack: ${this.acked} nack: ${this.nacked}`);
        }
        internal_1.assert(this.queue.channel);
        this.queue.getNativeChannel().nack(this.message, allUpTo, requeue);
        this.nacked = true;
    }
    reject(requeue = true) {
        this.nack(requeue);
    }
    isProcessed() {
        return this.acked || this.nacked;
    }
    static from(msg, queue) {
        const message = new ConsumerMessage(msg, queue);
        return message;
    }
}
exports.ConsumerMessage = ConsumerMessage;
//# sourceMappingURL=message.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const internal_1 = require("../lib/internal");
const testConfig = {
    rabbit: {
        uri: 'amqp://localhost',
    },
};
describe('Client tests', () => {
    describe('Connect tests', () => {
        it('should connect', async () => {
            await internal_1.default.connect(testConfig.rabbit.uri);
            await internal_1.default.close();
        });
        it('should not connect twice', async () => {
            await internal_1.default.connect(testConfig.rabbit.uri);
            await expect(internal_1.default.connect(testConfig.rabbit.uri)).rejects.toThrow();
            await internal_1.default.close();
        });
    });
    describe('Report error handling tests', () => {
        it('should handle reportError', async () => {
            await internal_1.default.connect(testConfig.rabbit.uri);
            for (let i = 0; i < 50; i++) {
                internal_1.default.reportError('channel', new Error('Test simulated error'));
                await expect(internal_1.default.waitForInitialize()).resolves.toBeUndefined();
                expect(internal_1.default.isReady).toBeTruthy();
            }
            await internal_1.default.close();
        });
        it('should handle reportError during consume', async () => {
            await internal_1.default.connect(testConfig.rabbit.uri);
            await internal_1.default.declareTopology({
                exchanges: [{ name: 'ex1', type: 'fanout' }],
                queues: [
                    { name: 'q1', options: { prefetch: 1 } },
                    { name: 'q2', options: { prefetch: 1 } },
                ],
                bindings: [
                    { source: 'ex1', destination: 'q1' },
                    { source: 'ex1', destination: 'q2' },
                ],
            });
            await internal_1.default.queues.q2.activateConsumer((message) => {
                message.ack();
            });
            for (let i = 0; i < 5; i++) {
                internal_1.default.reportError('channel', new Error('Test simulated error'));
                await expect(internal_1.default.waitForInitialize()).resolves.toBeUndefined();
                expect(internal_1.default.isReady).toBeTruthy();
            }
            await internal_1.default.close();
        });
        it('should not connect twice', async () => {
            await internal_1.default.connect(testConfig.rabbit.uri);
            await expect(internal_1.default.connect(testConfig.rabbit.uri)).rejects.toThrow();
            await internal_1.default.close();
        });
    });
    describe('declareTopology() tests', () => {
        beforeEach(async () => {
            await internal_1.default.connect(testConfig.rabbit.uri);
        });
        afterEach(async () => {
            await internal_1.default.close();
        });
        it('should declare topology', async () => {
            await internal_1.default.declareTopology({
                exchanges: [{ name: 'ex1', type: 'fanout' }],
                queues: [{ name: 'q1' }, { name: 'q2' }],
                bindings: [
                    { source: 'ex1', destination: 'q1' },
                    { source: 'ex1', destination: 'q2' },
                ],
            });
            expect(internal_1.default.queue('q1')).toBeDefined();
            expect(internal_1.default.queue('q2')).toBeDefined();
            expect(internal_1.default.exchange('ex1')).toBeDefined();
        });
        const consume = (_msg) => { };
        it('should declare topology with consumers', async () => {
            await internal_1.default.declareTopology({
                exchanges: [{ name: 'ex1', type: 'fanout' }],
                queues: [{ name: 'q1' }, { name: 'q2' }],
                bindings: [
                    { source: 'ex1', destination: 'q1' },
                    { source: 'ex1', destination: 'q2' },
                ],
                consumers: [
                    { queueName: 'q1', onMessage: consume, options: { noAck: true } },
                    { queueName: 'q2', onMessage: consume, options: { noAck: true } },
                ],
            });
        });
        it('should fail to declare topology with consumer of non existing queue', async () => {
            const promise = internal_1.default.declareTopology({
                exchanges: [{ name: 'ex1', type: 'fanout' }],
                queues: [{ name: 'q1' }, { name: 'q2' }],
                bindings: [
                    { source: 'ex1', destination: 'q1' },
                    { source: 'ex1', destination: 'q2' },
                ],
                consumers: [
                    { queueName: 'q-wrong', onMessage: consume, options: { noAck: true } },
                    { queueName: 'q2', onMessage: consume, options: { noAck: true } },
                ],
            });
            await expect(promise).rejects.toThrow();
        });
    });
    describe('declareQueue() tests', () => {
        beforeEach(async () => {
            await internal_1.default.connect(testConfig.rabbit.uri);
        });
        afterEach(async () => {
            await internal_1.default.close();
        });
        it('should declare queue', async () => {
            await internal_1.default.declareQueue('testQueue');
            await internal_1.default.deleteQueue('testQueue');
        });
        it('should fail to declare queue', async () => {
            await expect(internal_1.default.declareQueue()).rejects.toThrow();
        });
    });
    describe('declareExchange() tests', () => {
        beforeEach(async () => {
            await internal_1.default.connect(testConfig.rabbit.uri);
        });
        afterEach(async () => {
            await internal_1.default.close();
        });
        it('should declare exchange', async () => {
            await internal_1.default.declareExchange('testExchange', 'fanout');
            await internal_1.default.deleteExchange('testExchange');
        });
        it('should fail to declare exchange without a name', async () => {
            await expect(internal_1.default.declareExchange()).rejects.toThrow();
        });
        it('should fail to declare exchange without a type', async () => {
            await expect(internal_1.default.declareExchange('testExchange')).rejects.toThrow();
        });
    });
    describe('send() tests', () => {
        beforeEach(async () => {
            await internal_1.default.connect(testConfig.rabbit.uri);
            await internal_1.default.declareTopology({
                exchanges: [{ name: 'ex1', type: 'fanout' }],
                queues: [{ name: 'q1' }, { name: 'q2' }],
                bindings: [
                    { source: 'ex1', destination: 'q1' },
                    { source: 'ex1', destination: 'q2' },
                ],
            });
        });
        afterEach(async () => {
            await internal_1.default.close();
        });
        it('should send', async () => {
            await internal_1.default.send('q1', 'Test message');
            await internal_1.default.send('q2', 'Test message');
            await internal_1.default.send('ex1', 'Test message');
            await internal_1.default.send('ex1', 'Test message', { persistent: false }, '*');
        });
        it('should failed to send', async () => {
            await expect(internal_1.default.send('q0', 'Test message')).rejects.toThrow();
            await expect(internal_1.default.send('ex0', 'Test message')).rejects.toThrow();
            await expect(internal_1.default.send('q1', 'Test message', {}, '123')).rejects.toThrow();
            await expect(internal_1.default.send('q2', 'Test message')).resolves.toBeUndefined();
            await expect(internal_1.default.send('ex1', 'Test message')).resolves.toBeUndefined();
        });
    });
    describe('queue() tests', () => {
        beforeEach(async () => {
            await internal_1.default.connect(testConfig.rabbit.uri);
        });
        afterEach(async () => {
            await internal_1.default.close();
        });
        it('should return a queue by name', async () => {
            expect(() => internal_1.default.queue('test1')).toThrow();
            await internal_1.default.declareQueue('test1');
            expect(internal_1.default.queue('test1').name).toEqual('test1');
            await internal_1.default.declareQueue('test2');
            expect(internal_1.default.queue('test2').name).toEqual('test2');
            await internal_1.default.queue('test1').delete();
            await internal_1.default.queue('test2').delete();
            expect(() => internal_1.default.queue('test1')).toThrow();
            expect(() => internal_1.default.queue('test2')).toThrow();
        });
        it('should throw an error if queue was not declared or was deleted', async () => {
            expect(() => internal_1.default.queue('some-not-declared-queue-name')).toThrow();
            await internal_1.default.declareQueue('test1');
            expect(internal_1.default.queue('test1').name).toEqual('test1');
            await internal_1.default.queue('test1').delete();
            expect(() => internal_1.default.queue('test1')).toThrow();
        });
    });
    describe('exchange() tests', () => {
        beforeEach(async () => {
            await internal_1.default.connect(testConfig.rabbit.uri);
        });
        afterEach(async () => {
            await internal_1.default.close();
        });
        it('should return an exchange by name', async () => {
            expect(() => internal_1.default.exchange('test1')).toThrow();
            await internal_1.default.declareExchange('test1', 'fanout');
            expect(internal_1.default.exchange('test1').name).toEqual('test1');
            await internal_1.default.declareExchange('test2', 'direct');
            expect(internal_1.default.exchange('test2').name).toEqual('test2');
            await internal_1.default.exchange('test1').delete();
            await internal_1.default.exchange('test2').delete();
            expect(() => internal_1.default.exchange('test1')).toThrow();
            expect(() => internal_1.default.exchange('test2')).toThrow();
        });
        it('should throw an error if exchange was not declared or was deleted', async () => {
            expect(() => internal_1.default.exchange('some-not-declared-queue-name')).toThrow();
            await internal_1.default.declareExchange('test1', 'fanout');
            expect(internal_1.default.exchange('test1').name).toEqual('test1');
            await internal_1.default.exchange('test1').delete();
            expect(() => internal_1.default.exchange('test1')).toThrow();
        });
    });
});
//# sourceMappingURL=client.spec.js.map